---
phase: 02-challenge-engine
plan: 03
type: execute
wave: 3
depends_on: [02-01, 02-02]
files_modified: [
  engine/session_manager.py,
  api/app.py,
  api/challenges.py,
  api/flags.py,
  api/__init__.py,
  api/requirements.txt,
  scripts/api-server.sh,
  package.json
]
autonomous: true

must_haves:
  truths:
    - "User can spawn challenge containers via API"
    - "User can stop running challenge containers via API"
    - "User can submit flags for validation via API"
    - "System tracks active challenge sessions per user"
  artifacts:
    - path: "engine/session_manager.py"
      provides: "Session state management for active challenges"
      exports: ["SessionManager", "create_session", "get_session", "cleanup_session"]
    - path: "api/app.py"
      provides: "Flask REST API server"
      exports: ["create_app", "app"]
    - path: "api/challenges.py"
      provides: "Challenge management endpoints"
      exports: ["/api/challenges GET", "/api/challenges POST", "/api/challenges/<id> DELETE"]
    - path: "api/flags.py"
      provides: "Flag validation endpoint"
      exports: ["/api/flags POST"]
  key_links:
    - from: "api/challenges.py"
      to: "engine/orchestrator.py"
      via: "container spawn/stop calls"
      pattern: "orchestrator\\.(spawn|stop)_challenge"
    - from: "api/flags.py"
      to: "engine/flag_system.py"
      via: "flag validation"
      pattern: "validate_flag\\("
    - from: "engine/session_manager.py"
      to: "active container tracking"
      via: "session persistence"
      pattern: "session.*container_id"
---

<objective>
Implement session management and REST API endpoints to enable user interaction with the challenge engine through HTTP requests.

Purpose: Provide HTTP interface for challenge lifecycle management and flag validation, integrating orchestrator and flag systems into a cohesive API.
Output: Working REST API that allows spawning challenges, validating flags, and managing active sessions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-challenge-engine/02-RESEARCH.md
@.planning/phases/02-challenge-engine/02-01-SUMMARY.md
@.planning/phases/02-challenge-engine/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement session management system</name>
  <files>engine/session_manager.py</files>
  <action>
    Create session manager following research Pattern 2: Redis-Based Session Management, but using in-memory storage for local-only deployment. Implement SessionManager class with methods:
    - create_session(user_id, challenge_id, container_info): Create session with auto-cleanup timer
    - get_session(user_id, challenge_id): Retrieve active session data
    - cleanup_session(session_id): Remove session and stop container
    - list_user_sessions(user_id): Get all active sessions for user
    - cleanup_expired_sessions(): Remove sessions older than 1 hour

    Session data includes: container_id, container_port, challenge_id, user_id, created_at, expires_at.
    Use threading.Timer for automatic cleanup. Include comprehensive error handling.
    Integrate with existing monitoring for session metrics.
  </action>
  <verify>python -c "from engine.session_manager import SessionManager; sm = SessionManager(); print(sm.list_user_sessions('test'))" succeeds</verify>
  <done>Session manager can create, track, and cleanup challenge sessions with automatic expiration</done>
</task>

<task type="auto">
  <name>Task 2: Create Flask REST API endpoints</name>
  <files>api/app.py, api/challenges.py, api/flags.py, api/__init__.py, api/requirements.txt</files>
  <action>
    Create Flask-based REST API following research recommendations. Structure:

    api/app.py: Flask app factory with CORS, error handling, logging
    api/challenges.py: Challenge management endpoints:
    - GET /api/challenges: List available challenges from definitions
    - POST /api/challenges: Spawn challenge container for user
    - DELETE /api/challenges/<session_id>: Stop challenge container

    api/flags.py: Flag validation endpoint:
    - POST /api/flags: Validate submitted flag against active session

    Use request validation, proper HTTP status codes (200, 201, 400, 404, 500).
    Include API documentation in docstrings. Integrate with session manager and orchestrator.
    Follow research security patterns for API design. Include rate limiting considerations.
  </action>
  <verify>flask --app api.app run --host=127.0.0.1 --port=5000 starts without errors</verify>
  <done>Flask API server runs with all endpoints functional and proper error handling</done>
</task>

<task type="auto">
  <name>Task 3: Create API server startup and integration scripts</name>
  <files>scripts/api-server.sh, package.json</files>
  <action>
    Create API server management script with start/stop/restart/status operations. Script should:
    - Check for required dependencies (Flask, docker-py)
    - Start API server on port 5000 with proper logging
    - Include development/production modes
    - Integrate with existing monitoring stack
    - Handle graceful shutdown with session cleanup

    Add npm scripts to package.json:
    - "api:start": "./scripts/api-server.sh start"
    - "api:stop": "./scripts/api-server.sh stop"
    - "api:dev": "flask --app api.app run --debug"
    - "api:test": "curl -X GET http://localhost:5000/api/challenges"

    Update README with API usage examples and endpoint documentation.
    Ensure integration with existing scripts/setup.sh for full platform setup.
  </action>
  <verify>npm run api:start succeeds and curl http://localhost:5000/api/challenges returns JSON response</verify>
  <done>API server can be managed via npm scripts and integrates with project infrastructure</done>
</task>

</tasks>

<verification>
Test full challenge lifecycle:
1. `curl -X GET http://localhost:5000/api/challenges` - Lists available challenges
2. `curl -X POST http://localhost:5000/api/challenges -H "Content-Type: application/json" -d '{"challenge_id":"web-basic-xss","user_id":"test-user"}'` - Spawns challenge
3. `curl -X POST http://localhost:5000/api/flags -H "Content-Type: application/json" -d '{"flag":"flag{test}","session_id":"<session_id>"}'` - Validates flag
4. `curl -X DELETE http://localhost:5000/api/challenges/<session_id>` - Stops challenge

All endpoints return proper JSON responses and container appears/disappears in `podman ps`.
</verification>

<success_criteria>
- Session manager tracks active challenge instances with automatic cleanup
- REST API provides complete challenge lifecycle management
- Flag validation endpoint integrates with cryptographic flag system
- API server can be started/stopped via npm scripts
- Full challenge workflow (spawn -> validate -> stop) works end-to-end via HTTP
- Integration with existing monitoring and setup infrastructure
</success_criteria>

<output>
After completion, create `.planning/phases/02-challenge-engine/02-03-SUMMARY.md`
</output>