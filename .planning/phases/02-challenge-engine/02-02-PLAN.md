---
phase: 02-challenge-engine
plan: 02
type: tdd
wave: 2
depends_on: [02-01]
files_modified: [
  engine/flag_system.py,
  tests/test_flag_system.py,
  engine/requirements.txt
]
autonomous: true

must_haves:
  truths:
    - "System generates unique flags for each challenge instance"
    - "System validates submitted flags cryptographically"
    - "System prevents flag sharing between users or instances"
  artifacts:
    - path: "engine/flag_system.py"
      provides: "Cryptographic flag generation and validation"
      exports: ["FlagGenerator", "FlagValidator", "generate_unique_flag", "validate_flag"]
      min_lines: 50
    - path: "tests/test_flag_system.py"
      provides: "Comprehensive flag system test suite"
      exports: ["test_flag_generation", "test_flag_validation", "test_tamper_resistance"]
      min_lines: 80
  key_links:
    - from: "engine/flag_system.py"
      to: "HMAC crypto functions"
      via: "hmac.new and hashlib.sha256"
      pattern: "hmac\\.new.*sha256"
    - from: "engine/orchestrator.py"
      to: "engine/flag_system.py"
      via: "flag generation during spawn"
      pattern: "generate_unique_flag\\("
---

<objective>
Implement cryptographically secure flag generation and validation system using TDD methodology to ensure tamper-proof challenge scoring.

Purpose: Design robust flag system that prevents cheating while enabling proper challenge validation. TDD ensures correct cryptographic implementation before integration.
Output: Tested flag generation system that produces unique, unguessable flags per challenge instance.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-challenge-engine/02-RESEARCH.md
@.planning/phases/02-challenge-engine/02-01-SUMMARY.md
</context>

<feature>
  <name>Cryptographic Flag System</name>
  <files>engine/flag_system.py, tests/test_flag_system.py</files>
  <behavior>
    Flag generation must be cryptographically secure and unique per instance:
    - generate_unique_flag(challenge_id, user_id, instance_data, secret_key) -> "flag{hash16}"
    - validate_flag(submitted_flag, challenge_id, user_id, instance_data, secret_key) -> boolean
    - Same inputs always produce same flag (deterministic)
    - Different inputs produce different flags (unique)
    - Flag format: flag{16-character-hex} following CTF conventions
    - Uses HMAC-SHA256 with secret key for tamper resistance
    - Instance data includes timestamp and random nonce for uniqueness

    Test cases:
    - Same parameters -> same flag
    - Different user_id -> different flag
    - Different challenge_id -> different flag
    - Different instance_data -> different flag
    - Invalid flag submission -> validation fails
    - Tampered flag -> validation fails
    - Timing attack resistance via hmac.compare_digest
  </behavior>
  <implementation>
    Follow research Pattern 3: Tamper-Proof Flag Validation
    - Use hmac.new(secret_key, combined_input, hashlib.sha256)
    - Combined input: f"{challenge_id}:{user_id}:{instance_data}"
    - Truncate hash to 16 hex chars for readability
    - Use hmac.compare_digest for constant-time comparison
    - Include FlagGenerator and FlagValidator classes for clean interface
    - Support both string and class-based APIs for flexibility
  </implementation>
</feature>