---
phase: 05-container-lifecycle-hints
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "engine/health_monitor.py",
  "engine/orchestrator.py",
  "engine/session_manager.py"
]
autonomous: true

must_haves:
  truths:
    - "Challenge containers automatically recover from unhealthy states"
    - "System detects and logs container health issues"
    - "Failed containers are cleaned up automatically"
    - "Health monitoring operates without blocking main operations"
  artifacts:
    - path: "engine/health_monitor.py"
      provides: "Background container health monitoring with auto-recovery"
      exports: ["HealthMonitor", "ContainerHealthStatus"]
    - path: "engine/orchestrator.py"
      provides: "Health monitoring integration"
      contains: "health_monitor"
    - path: "engine/session_manager.py"
      provides: "Health status tracking in sessions"
      contains: "health_status"
  key_links:
    - from: "engine/health_monitor.py"
      to: "docker.containers.get"
      via: "Docker SDK health check integration"
      pattern: "container\\.attrs.*Health"
    - from: "engine/orchestrator.py"
      to: "engine/health_monitor.py"
      via: "monitoring initialization"
      pattern: "self\\.health_monitor"
---

<objective>
Implement container health monitoring system with automated recovery and background processing.

Purpose: Improve challenge container reliability by proactively detecting and recovering from container failures, ensuring consistent user experience.
Output: Health monitoring service integrated with existing orchestrator providing automated container recovery.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-container-lifecycle-hints/05-RESEARCH.md

# Current system context
@engine/orchestrator.py
@engine/session_manager.py
</context>

<tasks>

<task type="auto">
  <name>Create container health monitoring service</name>
  <files>engine/health_monitor.py</files>
  <action>
    Create HealthMonitor class with Docker SDK health check integration:

    - Background monitoring thread using threading (daemon=True)
    - Monitor container health using Docker SDK health status API
    - 30-second check interval with exponential backoff for failing containers
    - Auto-restart unhealthy containers with proper error handling
    - Health status tracking (healthy, unhealthy, starting, none)
    - Container cleanup for permanently failed containers
    - Thread-safe operations with proper logging

    Use Docker SDK health check pattern: container.attrs.get('State', {}).get('Health', {})

    Key methods:
    - start_monitoring(container_id) - begin monitoring specific container
    - stop_monitoring(container_id) - stop monitoring and cleanup
    - get_health_status(container_id) - return current health state
    - _monitor_loop() - background thread main loop

    Avoid blocking operations in main thread - all Docker API calls in background thread.
  </action>
  <verify>
    python -c "from engine.health_monitor import HealthMonitor; h = HealthMonitor(None); print('Health monitor created successfully')"
  </verify>
  <done>HealthMonitor class exists with Docker SDK integration, background thread monitoring, and auto-recovery capabilities</done>
</task>

<task type="auto">
  <name>Integrate health monitoring with orchestrator</name>
  <files>engine/orchestrator.py</files>
  <action>
    Extend ChallengeOrchestrator to integrate health monitoring:

    - Initialize HealthMonitor instance in __init__
    - Start monitoring when containers are spawned (in spawn_challenge)
    - Stop monitoring when containers are stopped (in stop_challenge)
    - Add get_container_health method for API integration
    - Log health events and recovery actions
    - Ensure monitoring cleanup on orchestrator shutdown

    Integration points:
    - After successful container spawn: health_monitor.start_monitoring(container_id)
    - In stop_challenge: health_monitor.stop_monitoring(container_id)
    - New method: get_container_health(container_id) -> dict

    Maintain backward compatibility - no changes to existing API contracts.
  </action>
  <verify>
    python -c "from engine.orchestrator import ChallengeOrchestrator; o = ChallengeOrchestrator(); print('Orchestrator with health monitoring initialized')"
  </verify>
  <done>ChallengeOrchestrator integrates health monitoring for spawned containers with automatic monitoring lifecycle</done>
</task>

<task type="auto">
  <name>Add health status to session tracking</name>
  <files>engine/session_manager.py</files>
  <action>
    Extend SessionInfo and SessionManager to include health status tracking:

    - Add health_status field to SessionInfo dataclass (default: "unknown")
    - Add update_session_health method to SessionManager
    - Include health status in session listing/retrieval methods
    - Update session health during cleanup operations

    Changes:
    - SessionInfo: Add health_status: str = "unknown" field
    - SessionManager: Add update_session_health(session_id, health_status) method
    - Modified get_session and list_user_sessions to include health data

    Ensure thread-safety with existing RLock mechanism. Health updates should not block session operations.
  </action>
  <verify>
    python -c "from engine.session_manager import SessionInfo; s = SessionInfo('1', '2', '3', '4', '5', 123, 456, 'healthy'); print('SessionInfo with health status created')"
  </verify>
  <done>SessionManager tracks container health status with thread-safe updates and health data in session info</done>
</task>

</tasks>

<verification>
- Health monitoring thread starts without blocking main operations
- Container health checks work via Docker SDK integration
- Failed containers trigger recovery actions
- Session health status updates correctly
</verification>

<success_criteria>
- Challenge containers have automated health monitoring with recovery
- System operates reliably with background health checks
- Container failures are detected and handled automatically
- Health status is tracked in session management
</success_criteria>

<output>
After completion, create `.planning/phases/05-container-lifecycle-hints/05-01-SUMMARY.md`
</output>