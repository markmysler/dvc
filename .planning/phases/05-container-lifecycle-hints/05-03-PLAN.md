---
phase: 05-container-lifecycle-hints
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified: [
  "engine/config_manager.py",
  "engine/orchestrator.py",
  "scripts/migrate-configs.py",
  "challenges/definitions/challenges.json"
]
autonomous: true

must_haves:
  truths:
    - "Challenge configurations have single source of truth"
    - "Individual config.json files are eliminated or deprecated"
    - "System loads challenge configs from unified source"
    - "Existing challenges continue to work after migration"
  artifacts:
    - path: "engine/config_manager.py"
      provides: "Configuration inheritance and merging system"
      exports: ["ConfigManager", "load_merged_challenge_config"]
    - path: "engine/orchestrator.py"
      provides: "Configuration manager integration"
      contains: "config_manager"
    - path: "scripts/migrate-configs.py"
      provides: "Migration script for existing configs"
      min_lines: 30
    - path: "challenges/definitions/challenges.json"
      provides: "Consolidated challenge configurations"
      contains: "migrated configurations"
  key_links:
    - from: "engine/orchestrator.py"
      to: "engine/config_manager.py"
      via: "unified configuration loading"
      pattern: "config_manager\\.get_challenge"
    - from: "engine/config_manager.py"
      to: "challenges/definitions/challenges.json"
      via: "single source configuration loading"
      pattern: "challenges\\.json"
    - from: "scripts/migrate-configs.py"
      to: "challenges/definitions/challenges.json"
      via: "configuration migration process"
      pattern: "migrate.*config"
---

<objective>
Simplify configuration management by eliminating duplicate config.json files and implementing unified configuration system with inheritance.

Purpose: Reduce configuration duplication and maintenance overhead by establishing single source of truth for challenge configurations.
Output: Unified configuration system with migration script and updated orchestrator integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-container-lifecycle-hints/05-RESEARCH.md

# Current configuration structure
@challenges/definitions/challenges.json
@challenges/test-challenge/config.json
@engine/orchestrator.py
@.planning/phases/05-container-lifecycle-hints/05-01-SUMMARY.md
@.planning/phases/05-container-lifecycle-hints/05-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create configuration management system</name>
  <files>engine/config_manager.py</files>
  <action>
    Create ConfigManager class using python-configuration library for unified config management:

    - Load master configuration from challenges/definitions/challenges.json
    - Implement configuration inheritance and merging
    - Support individual challenge config overrides (for transition period)
    - Fallback logic for backward compatibility
    - Configuration validation and error handling
    - Caching for performance

    Key methods:
    - get_challenge_config(challenge_id) -> dict - unified config for challenge
    - reload_configurations() - refresh config cache
    - validate_configuration(config) -> bool - config validation
    - list_available_challenges() -> List[str] - all challenge IDs

    Use python-configuration ConfigurationSet for proper inheritance:
    ```python
    from python_configuration import ConfigurationSet, config_from_dict, config_from_json

    # Master config + individual overrides (if exists)
    config_set = ConfigurationSet(
        config_from_json(master_path),
        config_from_dict(individual_overrides, read_from_file=False)
    )
    ```

    Fallback pattern: Check individual config.json files only if not found in master configuration.
  </action>
  <verify>
    python -c "from engine.config_manager import ConfigManager; c = ConfigManager(); print('ConfigManager created successfully')"
  </verify>
  <done>ConfigManager provides unified configuration loading with inheritance and backward compatibility</done>
</task>

<task type="auto">
  <name>Integrate configuration manager with orchestrator</name>
  <files>engine/orchestrator.py</files>
  <action>
    Update ChallengeOrchestrator to use ConfigManager for unified configuration loading:

    - Initialize ConfigManager instance in __init__
    - Replace direct challenges.json loading with config_manager.get_challenge_config()
    - Update _load_challenges method to use config manager
    - Add configuration reload capability
    - Maintain backward compatibility during transition

    Changes:
    - Import ConfigManager from config_manager
    - Initialize self.config_manager = ConfigManager() in __init__
    - Update self.challenges loading to use config_manager.list_available_challenges()
    - Replace direct config access with config_manager.get_challenge_config(challenge_id)

    Keep existing orchestrator API unchanged - internal implementation change only. Ensure all challenge loading flows through config manager.
  </action>
  <verify>
    python -c "from engine.orchestrator import ChallengeOrchestrator; o = ChallengeOrchestrator(); print('Orchestrator with unified config loading')"
  </verify>
  <done>ChallengeOrchestrator uses ConfigManager for unified configuration loading while maintaining existing API</done>
</task>

<task type="auto">
  <name>Create configuration migration script</name>
  <files>scripts/migrate-configs.py</files>
  <action>
    Create migration script to consolidate individual config.json files into unified challenges.json:

    - Scan challenges/ directory for individual config.json files
    - Load and validate existing individual configurations
    - Merge configurations into unified challenges/definitions/challenges.json
    - Backup original configurations before migration
    - Generate migration report with processed files
    - Handle duplicate challenge IDs and validation errors

    Script features:
    - CLI interface with dry-run option (--dry-run)
    - Verbose output showing migration steps (--verbose)
    - Backup creation before modification (--backup)
    - Migration validation and rollback capability

    Migration process:
    1. Backup existing challenges.json
    2. Scan for individual config.json files
    3. Load and validate each configuration
    4. Merge into unified configuration structure
    5. Write updated challenges.json
    6. Generate migration report

    Use colorama for colored CLI output. Handle errors gracefully with detailed logging.
  </action>
  <verify>
    python scripts/migrate-configs.py --dry-run | grep -i "migration"
  </verify>
  <done>Migration script consolidates individual config files into unified configuration with backup and validation</done>
</task>

<task type="auto">
  <name>Update unified configuration with migration</name>
  <files>challenges/definitions/challenges.json</files>
  <action>
    Run migration script to consolidate existing configurations and update challenges.json:

    - Execute migration script to consolidate test-challenge/config.json
    - Ensure migrated configuration maintains all original challenge properties
    - Verify hint integration from previous plan works with unified config
    - Validate configuration structure and required fields
    - Update configuration to include any missing fields for health monitoring integration

    Migration execution:
    1. Create backup of current challenges.json
    2. Run python scripts/migrate-configs.py --backup
    3. Verify migrated configuration includes all challenge data
    4. Test configuration loading through ConfigManager
    5. Ensure hints system works with unified configuration

    Post-migration validation:
    - All challenges loadable through config manager
    - Hint data preserved in metadata.hints
    - Container specs and security profiles intact
    - No configuration duplication between files
  </action>
  <verify>
    python -c "from engine.config_manager import ConfigManager; c = ConfigManager(); configs = c.list_available_challenges(); print(f'Available challenges: {configs}')"
  </verify>
  <done>Unified configuration contains all migrated challenge data with validated structure and working config manager integration</done>
</task>

</tasks>

<verification>
- Configuration manager loads challenges from unified source
- Migration script successfully consolidates config files
- Individual config.json files are deprecated/removed
- All systems work with unified configuration
</verification>

<success_criteria>
- Challenge configurations managed through single source of truth
- Configuration duplication eliminated between global and individual files
- Existing challenges continue working after configuration migration
- System provides clear configuration inheritance and override capabilities
</success_criteria>

<output>
After completion, create `.planning/phases/05-container-lifecycle-hints/05-03-SUMMARY.md`
</output>